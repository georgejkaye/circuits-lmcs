\documentclass{lmcs}

%% optional lists of keywords
\keywords{digital circuits,%
    symmetric traced monoidal categories, %
    denotational semantics, %
    operational semantics, %
    algebraic semantics, %
    string diagrams, %
    stream functions, %
    mealy machines}%

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{stmaryrd}

\usepackage{etoolbox}
\usepackage{xparse}

\usepackage{standalone}
\usepackage{wrapfig}
\usepackage{booktabs}
\usepackage{microtype}
\usepackage{multicol}
\usepackage{mathtools}

\usepackage{figures/tikzit}
\usepackage{tikz-cd}
\usepackage{todonotes}

\usepackage{bussproofs}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage[capitalise]{cleveref}

\input{macros/all.tex}
\input{figures/circuits.tikzdefs}
\input{figures/circuits.tikzstyles}

\newcommand{\bgcolour}{white}

\begin{document}

\title[A Complete Theory of Digital Circuits]{%
    A Complete Theory of Digital Circuits: %
    Denotational, Operational, and Algebraic Semantics}%

% \titlecomment{{\lsuper*}OPTIONAL comment concerning the title, \eg,
%     if a variant or an extended abstract of the paper has appeared elsewhere.}
% \thanks{thanks, optional.}

\author[D.R.~Ghica]{Dan R.\ Ghica\lmcsorcid{0000-0002-4003-8893}}[a]
\author[G.~Kaye]{George Kaye\lmcsorcid{0000-0002-0515-4055}}[a]
\author[D.~Sprunger]{David Sprunger\lmcsorcid{0000-0002-2518-4710}}[b]


\address{University of Birmingham}
\email{d.r.ghica@bham.ac.uk, georgejkaye@gmail.com}

\address{Indiana State University}
\email{david.sprunger@indstate.edu}

\begin{abstract}
    Digital circuits, despite having been studied for nearly a century and used
    at scale for about half that time, have until recently evaded a fully
    compositional theoretical understanding, in which arbitrary circuits may be
    freely composed together without consulting their internals.
    Recent work remedied this theoretical shortcoming by showing how digital
    circuits can be presented compositionally as morphisms in a freely generated
    symmetric traced category.
    However, this was done informally; in this paper we refine and expand the
    previous work in several ways, culminating in the presentation of three
    sound and complete semantics for digital circuits: denotational, operational
    and algebraic.
    For the denotational semantics, we establish a correspondence between
    stream functions with certain properties and circuits constructed
    syntactically.
    For the operational semantics, we present the reductions required to model
    how a circuit processes a value, including the addition of a new reduction
    for eliminating non-delay-guarded feedback; this leads to an adequate notion
    of observational equivalence for digital circuits.
    Finally, we define a new family of equations for translating circuits into
    bisimilar circuits of a `normal form', leading to a complete algebraic
    semantics for sequential circuits.
\end{abstract}

\maketitle

\section{Introduction}

Bothe was awarded the 1954 Nobel Prize in physics for creating the electronic
\(\andgate\) gate in 1924.
In the ensuing decades, exponential improvements in digital technology have led
to the development of the defining technologies of the modern world,
It may therefore seem improbable that there are theoretical gaps remaining in
our mathematical and logical understanding of digital circuits.

To be more precise, by `digital circuits' we primarily understand
\emph{electronic} circuits: deterministic circuits with clear notions of
input and output and which work on discrete signals.
A classic example is that of logical gates and basic memory elements of known
and fixed delays, but there are alternatives such as CMOS transistors operating
in saturation mode.
What we do not attempt to handle are circuits operating on continuous signals
(such as amplifiers) or in continuous time (such as asynchronous circuits), nor
\emph{electrical} circuits of resistors and capacitors, which are quite
different~\cite{boisseau2022string}.

Our goal is to devise a \emph{fully compositional} model of digital circuits.
By `fully compositional' we mean that a larger circuit can be built from smaller
circuits and interconnecting wires without paying heed to the internal structure
of these smaller circuits.
Of course, composition comes naturally to digital circuits and is widely used
informally~\cite{gordon1982model}.
Unfortunately one runs into an obstacle when trying to formalise this notion
mathematically: electrical connections can be created that inadvertently
connect the output of some elementary gate back to
its input such that no memory elements are encountered along the path.
Such a path, called a `combinational feedback loop' (or `cycle'), is not handled
by established mathematical theories of digital circuits, so conventional
digital design and engineering reject such circuits.
To enforce this restriction, we need to always look inside circuits as we
compose them, ensuring that no illegal combinational feedback loops are created,
or resort to some `safe' subset of circuits~\cite{christensen2021wire}.
This represents a failure of compositionality: what we want to do is to compose
\emph{any} circuits constructed from a fixed set of components.

On general principle, we have reason to expect that a compositional theory of
digital circuits may lead to more streamlined methods of analysis and
verification, which, in time, may also lead to new applications.
\emph{Combinational} circuits, which model functions, have an obvious
compositional syntax~\cite{lafont2003algebraic}, but \emph{sequential} circuits,
which contain delay and feedback, are more subtle.
The first forays towards a fully compositional syntactic and
categorical account of circuits have been made
recently~\cite{ghica2016categorical,ghica2017diagrammatic}, but they do not
paint a fully formal and coherent picture.
This paper develops the informal presentation into a mathematically
rigorous framework.

Our first contribution is to give, for the first time, a sound and complete
denotational semantics to digital circuits in the domain of causal and monotone
stream functions.
The completeness result depends on a novel albeit straightforward lifting of
Mealy machines~\cite{mealy1955method} to act on alphabets with a lattice
structure, utilising a handy coalgebraic perspective~\cite{rutten2006algebraic}.
Using Mealy machines to give a semantic interpretation to digital circuits is an
established methodology~\cite{kohavi2009switching}, and here they act as a
`bridge' between the syntactic and the semantic domain, showing how existing
circuit methodologies are compatible with our rigorous mathematical framework.

The second contribution of the paper is to generalise and systematise previous
efforts~\cite{ghica2017diagrammatic} to formulate a graph-rewriting-based
operational semantics for digital circuits.
The novelty is a new reduction rule for eliminating non-delay-guarded feedback
using a version of the Kleene fixpoint theorem, thus solving the problem of
productivity that previous operational semantics only solve partially.
The denotational and operational semantics together achieve the long-standing
goal of creating a semantic theory of digital circuits using the same
methodology as programming languages.

The methodological `glue' that binds together the two approaches is a new sound
and complete algebraic semantics, the third and final contribution of the paper.
This approach replaces the previous ad-hoc way of introducing equations for
digital circuits based on raw intuitions with a systematic approach guided by
the denotational semantics.
The key technical result of this method is deriving pseudo-normal forms of
digital circuits.

Although the motivation of this work is foundational, there are some early
hints of possible exciting applications, such as for partial evaluation and
blackboxing.
These are not yet industrial-strength applications, but the simplicity and
power of the framework must hold a certain degree of appeal and promise.

\section{Syntax}

Our \emph{soup du jour} is that of
\emph{sequential synchronous digital circuits}
constructed from primitive components such as logic gates or transistors.
These circuits are \emph{sequential} as they have a notion of \emph{state}:
outputs can be impacted by inputs in previous cycles rather than solely those in
the current cycle, and \emph{synchronous} because their state changes in time
with some global clock.

\begin{rem}
    Digital (electric) circuits are not to be confused with \emph{electronic}
    circuits of switches and resistors.
    Essentially, the difference boils down to the difference between traced
    categories and compact closed categories: digital circuits have a clear
    notion of \emph{causality} whereas electronic circuits are \emph{relational}
    in nature.
    For a study of the latter, see \cite{boisseau2022string}.
\end{rem}

\section{Circuit signatures}

To construct circuits, we define a category in which a morphism
\(m \to n\) is a circuit with \(m\) inputs and \(n\) outputs.
Rather than restricting to any particular gate set, we parameterise a given
category of circuits over a \emph{circuit signature} containing details about
the available components.

\begin{defi}[Circuit signature, value, primitive symbol]
    A \emph{circuit signature} \(\circuitsignature\) is a tuple \((
    \values,
    \disconnected,
    \circuitsignaturegates,
    \circuitsignaturearity,
    \circuitsignaturecoarity
    )\) where \(\values\) is a finite set of \emph{values}, \(
    \disconnected \in \values
    \) is a \emph{disconnected} value, \(\circuitsignaturegates\) is a (usually
    finite) set of \emph{primitive symbols}, \(
    \morph{\circuitsignaturearity}{\circuitsignaturegates}{\nat}
    \) is an \emph{arity} function and \(
    \morph{\circuitsignaturecoarity}{\circuitsignaturegates}{\nat}
    \) is a \emph{coarity} function.
\end{defi}

A particularly important signature, and one which we will turn to for the
majority of examples in this thesis, is that of gate-level circuits.

\begin{exa}[Gate-level circuits]\label{ex:belnap-signature}
    The circuit signature for \emph{gate-level circuits} is \(
    \belnapsignature \coloneqq (
    \belnapvalues,
    \bot,
    \belnapgates,
    \belnaparity,
    \belnapcoarity
    )\), where \(
    \belnapvalues \coloneqq \{\bot, \belnapfalse, \belnaptrue, \top\}
    \), respectively representing \emph{no} signal, a \emph{false} signal, a
    \emph{true} signal and \emph{both} signals at once, \(
    \belnapgates \coloneqq \{\andgate,\orgate,\notgate\}
    \), \(
    \belnaparity \coloneqq
    \andgate \mapsto 2,
    \orgate \mapsto 2,
    \notgate \mapsto 1
    \) and \(
    \belnapcoarity \coloneqq - \mapsto 1,
    \)
\end{exa}

\begin{rem}
    Using four values may come as a surprise to those expecting the usual
    `true' and 'false' logical values.
    This logical system is an old idea going back to
    Belnap~\cite{belnap1977useful} who remarked that this is `how a computer
    should think'.
    Rather than just thinking about how much \emph{truth content} a value
    carries, the four value system adds a notion of \emph{information content}:
    the \(\bot\) value is no information at all (a disconnected wire), whereas
    the \(\top\) value is both true and false information at once
    (a short circuit).
\end{rem}

\section{Combinational circuits}

Before diving straight into sequential circuits, we will define a category of
\emph{combinational circuits}.
These are circuits with no state; they compute \emph{functions} of their inputs.

\begin{defi}[Combinational circuit generators]
    Given a circuit signature \(
    \circuitsignature = (
    \circuitsignaturevalues,
    \bullet,
    \circuitsignaturegates,
    \circuitsignaturearity,
    \circuitsignaturecoarity
    )
    \), let the set \(\generators[\ccirc{}]\) of
    \emph{combinational circuit generators} be defined as the set containing \(
    \iltikzfig{circuits/components/gates/gate}[gate=g,colour=comb,dom=\circuitsignaturearity(g),cod=\circuitsignaturecoarity(g)]
    \) for each \(g \in \circuitsignaturegates\),
    \(\iltikzfig{strings/structure/monoid/init}[colour=comb]\),
    \(\iltikzfig{strings/structure/comonoid/copy}[colour=comb]\),
    \(\iltikzfig{strings/structure/monoid/merge}[colour=comb]\), and
    \(\iltikzfig{strings/structure/comonoid/discard}[colour=comb]\).
    We write \(\ccircsigma\) for the freely generated PROP
    \(\smc{\generators[\ccirc{}]}\).
\end{defi}

Each primitive symbol \(p \in \circuitsignaturegates\) has a corresponding
generator in \(\ccircsigma\).
The remaining generators are \emph{structural} generators
for manipulating
wires: these are present regardless of the signature.
In order, they are for \emph{introducing} wires, \emph{forking}
wires, \emph{joining} wires and \emph{eliminating} wires.

\begin{exa}
    The gate generators of \(\ccirc{\belnapsignature}\) are \(
    \iltikzfig{circuits/components/gates/and}
    \), \(
    \iltikzfig{circuits/components/gates/or}
    \), and \(
    \iltikzfig{circuits/components/gates/not}
    \).
\end{exa}

When drawing circuits, the coloured backgrounds of generators will often be
omitted in the interests of clarity.
Since the category is freely generated, morphisms are defined by
juxtaposing the generators in a given signature sequentially or in parallel with
each other, the identity and the symmetry.
Arbitrary combinational circuit morphisms defined in this way are drawn as light
boxes \iltikzfig{strings/category/f}[box=f,colour=comb,dom=m,cod=n].

\begin{nota}\label{not:arbitrary-width-structure}
    The structural generators are only defined on single bits, but it is
    straightforward to define versions for arbitrary bit wires.
    Much like we often draw multiple wires as one
    (\cref{not:arbitrary-width-wires}), we can also draw these `thicker'
    constructs in a similar way to the single-bit versions:
    \begin{gather*}
        \iltikzfig{strings/structure/monoid/init}[colour=comb,obj=n]
        \quad
        \iltikzfig{strings/structure/comonoid/copy}[colour=comb,obj=n]
        \quad
        \iltikzfig{strings/structure/monoid/merge}[colour=comb,obj=n]
        \quad
        \iltikzfig{strings/structure/comonoid/discard}[colour=comb,obj=n]
    \end{gather*}
    These composite constructs are defined inductively over the width of the
    wires.

    \begin{center}
        \begin{minipage}{0.48\textwidth}
            \centering
            \(\iltikzfig{strings/structure/comonoid/copy-unit}[obj=0,colour=comb]
            \coloneqq
            \iltikzfig{strings/monoidal/empty}
            \)
            \quad
            \(
            \iltikzfig{strings/structure/comonoid/copy}[obj=n+1,colour=comb]
            \coloneqq
            \iltikzfig{strings/structure/comonoid/copy-construction}
            \)

            \vspace{1em}

            \(
            \iltikzfig{strings/structure/monoid/init-unit}[obj=0,colour=comb]
            \coloneqq
            \iltikzfig{strings/monoidal/empty}
            \)\quad\(
            \iltikzfig{strings/structure/monoid/init}[obj=n+1,colour=comb]
            \coloneqq
            \iltikzfig{strings/structure/monoid/init-construction}
            \)
        \end{minipage}
        \quad
        \begin{minipage}{0.48\textwidth}
            \centering
            \(\iltikzfig{strings/structure/monoid/merge-unit}[obj=0,colour=comb]
            \coloneqq
            \iltikzfig{strings/monoidal/empty}
            \)
            \quad
            \(
            \iltikzfig{strings/structure/monoid/merge}[obj=n+1,colour=comb]
            \coloneqq
            \iltikzfig{strings/structure/monoid/merge-construction}
            \)

            \vspace{1em}

            \(\iltikzfig{strings/structure/comonoid/discard-unit}[obj=0,colour=comb]
            \coloneqq
            \iltikzfig{strings/monoidal/empty}
            \)\quad\(
            \iltikzfig{strings/structure/comonoid/discard}[obj=n+1,colour=comb]
            \coloneqq
            \iltikzfig{strings/structure/comonoid/discard-construction}
            \)
        \end{minipage}
    \end{center}
\end{nota}

\begin{rem}
    As mentioned during \cref{not:arbitrary-width-wires}, wires of zero width
    are usually drawn as empty space; in a similar fashion the zero width fork,
    join, and elimination constructs can be drawn as empty space or using
    `faded' wires.
\end{rem}

\begin{exa}[More logic gates]
    The \(\andgate\), \(\orgate\), and \(\notgate\) gates are not the only logic
    gates used in circuit design.
    A \(\nandgate\) gate \(
    \iltikzfig{circuits/components/gates/nand}
    \) acts as the inverse of an \(\andgate\) gate: it
    outputs true if none of the inputs are true.
    Similarly, a \(\norgate\) gate \(
    \iltikzfig{circuits/components/gates/nor}
    \) is the inverse of an \(\orgate\) gate.
    These two gates can be constructed in terms of the primitive gates in
    \(\belnapsignature\):

    \[
        \iltikzfig{circuits/components/gates/nand}
        \coloneqq
        \iltikzfig{circuits/components/gates/nand-construction}
        \qquad
        \iltikzfig{circuits/components/gates/nor}
        \coloneqq
        \iltikzfig{circuits/components/gates/nor-construction}
    \]

    Another type of gate is the \(\xorgate\) gate \(
    \iltikzfig{circuits/components/gates/xor}
    \), which outputs true if and only if exactly one of the inputs is
    true.
    In \(\ccirc{\belnapsignature}\) this is constructed as \[
        \iltikzfig{circuits/components/gates/xor}
        \coloneqq
        \iltikzfig{circuits/components/gates/xor-construction-1}
        =
        \iltikzfig{circuits/components/gates/xor-construction-2}.
    \]
\end{exa}

\begin{exa}[Half adder]\label{ex:half-adder}
    The \(\xorgate\) gate is used in a classic combinational circuit known as a
    \emph{half adder}, the basic building block of circuit arithmetic.
    A half adder takes two inputs and computes their \emph{sum} modulo
    \(2\) and the resulting \emph{carry}.
    That is to say, \(0+0\) has sum \(0\) and carry \(0\), \(1+0\) and \(0+1\)
    have sum \(1\) and carry \(0\), and \(1+1\) has sum \(0\) and carry \(1\).

    The sum is computed using an \(\xorgate\) gate and the carry by an
    \(\andgate\) gate.
    The design of a half adder along with its construction in
    \(\ccirc{\belnapsignature}\) is shown below.
    \[
        \iltikzfig{circuits/examples/half-adder/circuit}
        \qquad
        \iltikzfig{circuits/examples/half-adder/circuit-ccirc}
        =
        \iltikzfig{circuits/examples/half-adder/circuit-ccirc-2}
    \]
\end{exa}

\section{Sequential circuits}

Combinational circuits compute functions of their inputs, but have no internal
state.
This is all very well for doing simple calculations, but for all but the most
simple of circuits we need to be able to have \emph{memory}.
As we have mentioned earlier, such circuits are called
\emph{sequential circuits}.

Circuits gain state with \emph{delay} and \emph{feedback}.
The latter means we need to move into a symmetric \emph{traced} monoidal category.

\begin{defi}[Sequential circuits]
    For a circuit signature \(\circuitsignature\) with value set \(\values\),
    let \(\scircsigma\) be the STMC freely generated over the generators of
    \(\ccircsigma\) along with new generators \(
    \iltikzfig{circuits/components/values/vs}[val=v]
    \) for each \(v \in \values \setminus \bullet\), and a generator \(
    \iltikzfig{circuits/components/waveforms/delay}
    \).
\end{defi}

The first set of generators are \emph{instantaneous values} for each value in
\(\values \setminus \bullet\).
Value generators are intended to be interpreted as an \emph{initial state}:
in the first cycle of execution they will emit their value, and produce the
disconnected \(\bullet\) value after that.
This is why there is no \(\bullet\) value generator; instead it is a
\emph{combinational} generator \(
\iltikzfig{strings/structure/monoid/init}[colour=comb]
\) intended to always produce the \(\bullet\) value.

\begin{nota}
    Although \(
    \iltikzfig{strings/structure/monoid/init}[colour=comb]
    \) is itself not a sequential value, when we refer to an arbitrary value
    \(
    \iltikzfig{circuits/components/values/vs}[val=v]
    \), \(v\) can be any value in \(\values\) including \(\bullet\).
    For a word of values \(\listvar{v} \in \valuetuple{n}\) (again possibly
    including \(\bullet\)), we may draw multiple value generators collapsed into
    one as \(
    \iltikzfig{circuits/components/values/vs}[val=\listvar{v},width=n]
    \), defined inductively over \(\listvar{v}\) as
    \begin{gather*}
        \iltikzfig{circuits/components/values/vs}[val=\varepsilon,width=0]
        \coloneqq
        \iltikzfig{strings/monoidal/empty}
        \qquad
        \iltikzfig{circuits/components/values/vs-even-longer}[val=v\listvar{w},width=n+1]
        \coloneqq
        \iltikzfig{circuits/components/values/vs-construction}
    \end{gather*}
\end{nota}

\begin{exa}
    The `values' of \(\scirc{\belnapsignature}\) are \(
    \iltikzfig{strings/structure/monoid/init}[colour=comb]
    \), \(
    \iltikzfig{circuits/components/values/vs}[val=\belnapfalse]
    \), \(
    \iltikzfig{circuits/components/values/vs}[val=\belnaptrue]
    \), \(
    \iltikzfig{circuits/components/values/vs}[val=\top]
    \); the first is a combinational generator and the latter three are
    sequential.
\end{exa}

The delay component is the opposite of a value; in the first cycle of execution
it is intended to produce the \(\bullet\) value, but in future cycles it outputs
the signal it received in the previous cycle.

\begin{rem}
    While the mathematical interpretation of a delay is straightforward, the
    physical aspect of a digital circuit it models is less clear.
    An obvious interpretation could be that the delay models a D flipflop in
    a clocked circuit, so the delay is one clock cycle.
    A more subtle interpretation is the `minimum obervable duration'; in this
    case the delay models inertial delay on wires up to some fixed precision.
\end{rem}

\begin{nota}
    Like values, we can derive delay components for arbitrary-bit wires, drawn
    like \(
    \iltikzfig{circuits/components/waveforms/delay}[width=n]
    \).
    \begin{gather*}
        \iltikzfig{circuits/components/waveforms/unit-delay}[width=0]
        \coloneqq
        \iltikzfig{strings/monoidal/empty}
        \qquad
        \iltikzfig{circuits/components/waveforms/delay}[width=n+1]
        \coloneqq
        \iltikzfig{circuits/components/waveforms/delay-construction}
    \end{gather*}
\end{nota}

Often one may also want to think about delays with some explicit `initial
value', like a sort of register.
This is so common that we introduce special notation for it.

\begin{nota}[Register]\label{not:register}
    For a word \(\listvar{v} \in \valuetuple{m}\), let \(
    \iltikzfig{circuits/components/waveforms/register}
    \coloneqq
    \iltikzfig{circuits/components/waveforms/register-shorthand}
    \).
\end{nota}

To distinguish them from combinational circuits, arbitrary sequential circuit
morphisms are drawn as green boxes \(
\iltikzfig{strings/category/f}[box=f,colour=seq,dom=m,cod=n]
\).

\begin{exa}[SR latch]\label{ex:sr-latch}
    A sequential circuit one might come across early on in an electronics
    textbook is the \emph{SR NOR latch}, one of the simplest registers.
    A possible design and interpretation in \(\scirc{\belnapsignature}\) are
    illustrated below.
    \begin{gather*}
        \iltikzfig{circuits/examples/sr-latch/real-circuit}
        \qquad
        \iltikzfig{circuits/examples/sr-latch/circuit}
    \end{gather*}

    SR NOR latches are used to hold state.
    They have two inputs: Reset (\(\mathsf{R}\)) and Set (\(\mathsf{S}\)), and
    two outputs \(\mathsf{Q}\) and \(\overline{\mathsf{Q}}\) which are always
    negations of each other.
    When Set receives a true signal, the \(\mathsf{Q}\) output is forced true,
    and will remain as such even if the Set input stops being pulsed true.
    It is only when the Reset input is pulsed true that the \(\mathsf{Q}\)
    output will return to false.
    (It is illegal for both Set and Reset to be pulsed high simultaneously; this
    issue is fixed in more complicated latches).

    SR latches work because of delays in how gates and wires transmit signals;
    one of the feedback loops between the two \(\norgate\) gates will `win'.
    We can model this in \(\scircsigma\) by using a different number of delay
    generators between the top and the bottom of the latch.
    We have opted for just the one because otherwise the upcoming examples
    become excessively complicated, but any number would do, so long as the top
    and bottom differ.
\end{exa}

\section{Generalised circuit signatures}

In a circuit signature, gates are assigned a number of input and output wires.
This serves us well when we want to model lower level circuits in which we
really are dealing with single-bit wires.
However, when designing circuits it is often advantageous to work at a higher
level of abstraction with `thicker' wires carrying words of information.
For example, the values in the circuits could be used to represent binary
numbers.

This can still be modelled in \(\scircsigma\) `as is' by using lots of parallel
wires to connect to the various primitives, but this can get messy with wires
all over the place.
Instead, we will introduce a generalisation of circuit signatures in which these
thicker buses of wires are treated as first-class objects.

\begin{defi}[Generalised circuit signature]
    A \emph{generalised circuit signature} \(\circuitsignature\) is a tuple \((
    \values,
    \disconnected,
    \circuitsignaturegates,
    \circuitsignaturearity,
    \circuitsignaturecoarity
    )\) where \(\values\) is a finite set of values, \(
    \disconnected \in \values
    \) is a \emph{disconnected} value, \(\circuitsignaturegates\) is a (usually
    finite) set of \emph{gate symbols}, \(
    \morph{\circuitsignaturearity}{\circuitsignaturegates}{\natplus^\star}
    \) is an \emph{arity} function and \(
    \morph{\circuitsignaturecoarity}{\circuitsignaturegates}{\natplus^\star}
    \) is a \emph{coarity} function.
\end{defi}

In a generalised circuit signature, primitives are typed with input and output
\emph{words} rather than just natural numbers.

\begin{exa}
    The generalised circuit signature for \emph{simple arithmetic circuits} is
    \(
    \belnapsignature^+ \coloneqq \left(
    \belnapvalues,
    \bot,
    \belnapgates^+,
    \belnaparity^+,
    \belnapcoarity^+
    \right)
    \), where \begin{gather*}
        \belnapgates
        \coloneqq \{
        \andgate_{k,n},
        \orgate_{k,n},
        \notgate_{n},
        \mathsf{add}_n
        \,|\,
        n \in \natplus
        \}
        \\[0.5em]
        \belnaparity^+(\andgate_{k,n}) \coloneqq [n \,|\, i < k]
        \quad
        \belnaparity^+(\orgate_{k,n}) \coloneqq [n \,|\, i < k]
        \\[0.5em]
        \belnaparity^+(\notgate_{n}) \coloneqq [n]
        \quad
        \belnaparity^+(\mathsf{add}_n) \coloneqq [n,n]
        \\[0.5em]
        \belnapcoarity^+
        \coloneqq
        \andgate_{k,n} \mapsto [n],
        \orgate_{k,n} \mapsto [n],
        \notgate_n \mapsto [n],
        \mathsf{add}_n \mapsto [n]
    \end{gather*}
    The gates \(\andgate_{k,n}\) and \(\orgate_{k,n}\) are gates that operate
    on \(k\) input wires of width \(n\); similarly the \(\notgate_n\) gate
    operates on input wires of width \(n\).
    The \(\mathsf{add}_n\) component represents an adder that takes as input
    two \(n\)-bit wires and outputs their \(n\)-bit sum.
\end{exa}

Just like a monochromatic circuit signature generates monochromatic PROPs, a
generalised circuit signature generates \(\natplus\)-coloured PROPs.

\begin{defi}
    For a generalised circuit signature \(\circuitsignature\), let the set
    \(\generators[\ccirc{}^+]\) of
    \emph{generalised combinational circuit generators} be defined as the set
    containing
    \begin{gather*}
        \iltikzfig{circuits/components/gates/gate}[gate=g,colour=comb,dom=\circuitsignaturearity(g),cod=\circuitsignaturecoarity(g)]
        \,
        \text{for each}\ g \in \circuitsignaturegates
        \\[1em]
        \iltikzfig{strings/structure/monoid/init}[colour=comb,obj=n]
        \quad
        \iltikzfig{strings/structure/comonoid/copy}[colour=comb,obj=n]
        \quad
        \iltikzfig{strings/structure/monoid/merge}[colour=comb, obj=n]
        \quad
        \iltikzfig{strings/structure/comonoid/discard}[colour=comb,obj=n]
        \quad
        \iltikzfig{strings/strictifiers/expand}[colour=comb,obj=n]
        \quad
        \iltikzfig{strings/strictifiers/collapse}[colour=comb,obj=n]
        \quad
        \text{for each}\ n \in \natplus
    \end{gather*}
    We write \(\ccircsigmag\) for the freely generated \(\natplus\)-coloured
    PROP \(\smc{\generators[\ccirc{}^+]}\).
\end{defi}

Most of the generators  in \(\ccircsigmag\) are fairly straightforward
generalisations of the primitives in \(\ccircsigma\) to act on each
colour (width) of wires.
The only new generators are the \emph{bundlers} at the end of the bottom row;
their intended meaning is that they can be used to \emph{split} and
\emph{combine} bundles of wire buses into bundles with different widths.
These constructs were first proposed by Wilson et al in~\cite{wilson2023string}
as a notation for \emph{non-strict categories}.
We take inspiration from their observation that a similar idea could also be
applied to strict categories.

\begin{exa}[ALU]
    The computation of a CPU is performed by an \emph{arithmetic logic unit},
    or ALU for short.
    An ALU takes some input wires of a fixed width and performs an operation
    on them given some control signal.
    While ALUs can often perform many different operations, we will look at an
    example operating on four-bit wires that performs a bitwise \(\andgate\)
    operation when the control is false, and an addition when the control is
    true.
    This ALU will also produce an output indicating if the sum is zero, and
    the sign of the sum; these auxiliary outputs only produce useful output when
    the addition operation is selected.

    \begin{center}
        \iltikzfig{circuits/examples/alu}
    \end{center}

    To apply the single-bit control to the four-bit \(\andgate\) gates, the
    top bundler and forks are used to create a wire containing only the
    original bit.

    The sum is zero if all of the bits are false.
    To determine this, the \(\orgate_{1,4}\) gate folds the four-bit sum into
    a one-bit value which is true if at least one of the bits is true.
    The \(\notgate_{1,1}\) inverts the output to produce true if there are no
    true bits.

    In two's complement representation, the most significant bit indicates if
    the sum is negative.
    To model this, the lower bundler splits the four-bit sum into its
    constituent bits, discarding the least significant three.
\end{exa}

Sequential circuits are generalised in the same way.

\begin{defi}
    For a generalised circuit signature \(\circuitsignature\), let the set
    \(\generators[\scirc{}^+]\) of
    \emph{generalised sequential circuit generators} be the set of
    generalised combinational circuit generators along with
    \(
    \iltikzfig{circuits/components/values/vs}[val=\listvar{v},width=n]
    \) for each \(n \in \natplus\) and \(\listvar{v} \in \valuetuple{n}\), and
    \(
    \iltikzfig{circuits/components/waveforms/delay}[width=n]
    \) for each \(n \in \natplus\).
    We write \(\scircsigmag\) for the freely generated PROP
    \(\stmc{\generators[\scirc{}^+]}\).
\end{defi}

Most of the upcoming results will be shown for the monochromatic case, as the
proofs are more elegant.
However, most of the results also generalise to the coloured case, and this will
be remarked upon throughout.

\bibliographystyle{alphaurl}
\bibliography{refs/refs}

\end{document}